
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>replication-controller: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/dell/csm-replication/controllers/replication-controller/dellcsireplicationgroup_controller.go (86.8%)</option>
				
				<option value="file1">github.com/dell/csm-replication/controllers/replication-controller/persistentvolume_controller.go (85.4%)</option>
				
				<option value="file2">github.com/dell/csm-replication/controllers/replication-controller/persistentvolumeclaim_controller.go (84.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
 Copyright Â© 2021-2023 Dell Inc. or its subsidiaries. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package replicationcontroller

import (
        "context"
        "encoding/json"
        "fmt"
        "strconv"
        "strings"
        "time"

        csireplicator "github.com/dell/csm-replication/controllers/csi-replicator"
        "github.com/dell/csm-replication/pkg/common"

        repv1 "github.com/dell/csm-replication/api/v1"
        controller "github.com/dell/csm-replication/controllers"
        "github.com/dell/csm-replication/pkg/connection"
        s1 "github.com/kubernetes-csi/external-snapshotter/client/v4/apis/volumesnapshot/v1"
        v1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        reconciler "sigs.k8s.io/controller-runtime/pkg/controller"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"

        "github.com/go-logr/logr"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/tools/record"
        "k8s.io/client-go/util/workqueue"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

const (
        eventTypeNormal    = "Normal"
        eventTypeWarning   = "Warning"
        eventReasonUpdated = "Updated"
)

var (
        getDellCsiReplicationGroupGetSnapshotClass = func(r connection.RemoteClusterClient, ctx context.Context, snapClassName string) (*s1.VolumeSnapshotClass, error) <span class="cov2" title="2">{
                return r.GetSnapshotClass(ctx, snapClassName)
        }</span>
        getDellCsiReplicationGroupGetNamespace = func(r connection.RemoteClusterClient, ctx context.Context, namespace string) (*v1.Namespace, error) <span class="cov1" title="1">{
                return r.GetNamespace(ctx, namespace)
        }</span>
        getDellCsiReplicationGroupCreateNamespace = func(r connection.RemoteClusterClient, ctx context.Context, content *v1.Namespace) error <span class="cov1" title="1">{
                return r.CreateNamespace(ctx, content)
        }</span>
        getDellCsiReplicationGroupCreateSnapshotContent = func(r connection.RemoteClusterClient, ctx context.Context, snapContent *s1.VolumeSnapshotContent) error <span class="cov1" title="1">{
                return r.CreateSnapshotContent(ctx, snapContent)
        }</span>
        getDellCsiReplicationGroupCreateSnapshotObject = func(remoteClient connection.RemoteClusterClient, ctx context.Context, snapshot *s1.VolumeSnapshot) error <span class="cov1" title="1">{
                return remoteClient.CreateSnapshotObject(ctx, snapshot)
        }</span>
        getDellCsiReplicationGroupProcessSnapshotEvent = func(r *ReplicationGroupReconciler, ctx context.Context, group *repv1.DellCSIReplicationGroup, remoteClient connection.RemoteClusterClient, log logr.Logger) error <span class="cov0" title="0">{
                return r.processSnapshotEvent(ctx, group, remoteClient, log)
        }</span>
        getDellCsiReplicationGroupUpdate = func(r *ReplicationGroupReconciler, ctx context.Context, group *repv1.DellCSIReplicationGroup) error <span class="cov1" title="1">{
                return r.Update(ctx, group)
        }</span>
)

// ReplicationGroupReconciler reconciles a ReplicationGroup object
type ReplicationGroupReconciler struct {
        client.Client
        Log                logr.Logger
        Scheme             *runtime.Scheme
        EventRecorder      record.EventRecorder
        PVCRequeueInterval time.Duration
        Config             connection.MultiClusterClient
        Domain             string
}

// +kubebuilder:rbac:groups=replication.storage.dell.com,resources=dellcsireplicationgroups,verbs=get;list;watch;update;patch;delete;create
// +kubebuilder:rbac:groups=replication.storage.dell.com,resources=dellcsireplicationgroups/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=core,resources=events,verbs=list;watch;create;update;patch

// Reconcile contains reconciliation logic that updates ReplicationGroup depending on it's current state
func (r *ReplicationGroupReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov7" title="15">{
        log := r.Log.WithValues("dellcsireplicationgroup", req.Name)
        ctx = context.WithValue(ctx, common.LoggerContextKey, log)

        localRG := new(repv1.DellCSIReplicationGroup)
        err := r.Get(ctx, req.NamespacedName, localRG)
        if err != nil </span><span class="cov1" title="1">{
                return ctrl.Result{}, client.IgnoreNotFound(err)
        }</span>
        <span class="cov7" title="14">log.V(common.InfoLevel).Info("Reconciling RG event!!!")
        localRGName := req.Name
        remoteRGName := localRG.Annotations[controller.RemoteReplicationGroup]
        if remoteRGName == "" </span><span class="cov1" title="1">{
                remoteRGName = localRGName
        }</span>
        <span class="cov7" title="14">rgSyncComplete := false

        if localRG.Annotations == nil </span><span class="cov1" title="1">{
                log.V(common.InfoLevel).Info("RG is not ready yet, requeue as we will get another event")
                return ctrl.Result{}, nil
        }</span> else<span class="cov6" title="13"> if localRG.Annotations[controller.RGSyncComplete] == "yes" </span><span class="cov3" title="3">{
                log.V(common.DebugLevel).Info("RG Sync already completed")
                remoteRGName = localRG.Annotations[controller.RemoteReplicationGroup]
                rgSyncComplete = true
                // Continue as we can re verify
        }</span>

        <span class="cov6" title="13">localClusterID := r.Config.GetClusterID()
        remoteClusterID := localRG.Spec.RemoteClusterID

        if remoteClusterID == controller.Self </span><span class="cov4" title="5">{
                localClusterID = controller.Self

                if !strings.HasPrefix(localRGName, replicated) </span><span class="cov4" title="4">{
                        remoteRGName = replicated + "-" + localRGName
                }</span>
        }

        <span class="cov6" title="13">annotations := make(map[string]string)
        annotations[controller.RemoteReplicationGroup] = localRGName
        annotations[controller.RemoteRGRetentionPolicy] = localRG.Annotations[controller.RemoteRGRetentionPolicy]
        annotations[controller.RemoteClusterID] = localClusterID

        labels := make(map[string]string)

        labels[controller.DriverName] = localRG.Labels[controller.DriverName]
        labels[controller.RemoteClusterID] = localClusterID

        // Apply driver specific labels
        remoteRGAttributes := localRG.Spec.RemoteProtectionGroupAttributes
        contextPrefix := localRG.Annotations[controller.ContextPrefix]
        if contextPrefix != "" </span><span class="cov6" title="12">{
                for k, v := range remoteRGAttributes </span><span class="cov10" title="49">{
                        if strings.HasPrefix(k, contextPrefix) </span><span class="cov1" title="1">{
                                labelKey := fmt.Sprintf("%s%s", r.Domain, strings.TrimPrefix(k, contextPrefix))
                                labels[labelKey] = v
                        }</span>
                }
        }

        <span class="cov6" title="13">remoteRG := &amp;repv1.DellCSIReplicationGroup{
                ObjectMeta: metav1.ObjectMeta{
                        Name:        remoteRGName,
                        Annotations: annotations,
                        Labels:      labels,
                },
                Spec: repv1.DellCSIReplicationGroupSpec{
                        DriverName:                      localRG.Spec.DriverName,
                        Action:                          "",
                        RemoteClusterID:                 localClusterID,
                        ProtectionGroupID:               localRG.Spec.RemoteProtectionGroupID,
                        ProtectionGroupAttributes:       localRG.Spec.RemoteProtectionGroupAttributes,
                        RemoteProtectionGroupID:         localRG.Spec.ProtectionGroupID,
                        RemoteProtectionGroupAttributes: localRG.Spec.ProtectionGroupAttributes,
                },
        }

        // Try to get the client
        remoteClient, err := r.Config.GetConnection(remoteClusterID)
        if err != nil </span><span class="cov1" title="1">{
                return ctrl.Result{}, err
        }</span>

        // Check for RG retention policy annotation
        <span class="cov6" title="12">retentionPolicy, ok := localRG.Annotations[controller.RemoteRGRetentionPolicy]
        if !ok </span><span class="cov1" title="1">{
                log.Info(fmt.Sprintf("RetentionPolicy:found:%v,value--&gt;%s", ok, retentionPolicy))
                log.Info("Retention policy not set, using retain as the default policy")
                retentionPolicy = controller.RemoteRetentionValueRetain // we will default to retain the RG if there is no retention policy is set
        }</span>

        // Handle RG deletion if timestamp is set
        <span class="cov6" title="12">if !localRG.DeletionTimestamp.IsZero() </span><span class="cov1" title="1">{
                // Process deletion of remote RG
                log.V(common.InfoLevel).Info("Deletion timestamp is not zero")
                log.V(common.InfoLevel).WithValues(localRG.Annotations).Info("Annotations")
                _, ok := localRG.Annotations[controller.DeletionRequested]
                log.V(common.InfoLevel).WithValues(ok).Info("Deletion requested?", ok)

                if _, ok := localRG.Annotations[controller.DeletionRequested]; !ok </span><span class="cov1" title="1">{
                        log.V(common.InfoLevel).Info("Deletion requested annotation not found")
                        remoteRG, err := remoteClient.GetReplicationGroup(ctx, localRG.Annotations[controller.RemoteReplicationGroup])
                        if err != nil </span><span class="cov0" title="0">{
                                log.V(common.ErrorLevel).WithValues(err.Error()).Info("error getting replication group")
                                // If remote RG doesn't exist, proceed to removing finalizer
                                if !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                        log.Error(err, "Failed to get remote replication group")
                                        return ctrl.Result{}, err
                                }</span>
                        } else<span class="cov1" title="1"> {
                                log.V(common.InfoLevel).Info("Got remote RG")
                                if strings.ToLower(retentionPolicy) == controller.RemoteRetentionValueDelete </span><span class="cov1" title="1">{
                                        log.Info("Retention policy is set to Delete")
                                        if _, ok := remoteRG.Annotations[controller.DeletionRequested]; !ok </span><span class="cov1" title="1">{
                                                // Add annotation on the remote RG to request its deletion
                                                remoteRGCopy := remoteRG.DeepCopy()
                                                controller.AddAnnotation(remoteRGCopy, controller.DeletionRequested, "yes")
                                                err := remoteClient.UpdateReplicationGroup(ctx, remoteRGCopy)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return ctrl.Result{}, err
                                                }</span>
                                                // Resetting the rate-limiter to requeue for the deletion of remote RG
                                                <span class="cov1" title="1">return ctrl.Result{RequeueAfter: 1 * time.Millisecond}, nil</span>
                                        }
                                        // Requeueing because the remote PV still exists
                                        <span class="cov0" title="0">return ctrl.Result{Requeue: true}, nil</span>
                                }
                        }
                }

                <span class="cov0" title="0">log.V(common.InfoLevel).Info("Removing finalizer RGFinalizer")
                finalizerRemoved := controller.RemoveFinalizerIfExists(localRG, controller.RGFinalizer)
                if finalizerRemoved </span><span class="cov0" title="0">{
                        log.V(common.InfoLevel).Info("Updating rg copy to remove finalizer")
                        return ctrl.Result{}, r.Update(ctx, localRG)
                }</span>
        }

        <span class="cov6" title="11">rgCopy := localRG.DeepCopy()

        log.V(common.InfoLevel).Info("Adding finalizer RGFinalizer")
        // Check for the finalizer; add, if doesn't exist
        if finalizerAdded := controller.AddFinalizerIfNotExist(rgCopy, controller.RGFinalizer); finalizerAdded </span><span class="cov2" title="2">{
                log.V(common.InfoLevel).Info("Finalizer not found adding it")
                return ctrl.Result{}, r.Update(ctx, rgCopy)
        }</span>
        <span class="cov6" title="9">log.V(common.InfoLevel).Info("Trying to delete RG if deletion request annotation found")
        // Check for deletion request annotation
        if _, ok := rgCopy.Annotations[controller.DeletionRequested]; ok </span><span class="cov0" title="0">{
                log.V(common.InfoLevel).Info("Deletion Requested annotation found and deleting the remote RG")
                return ctrl.Result{}, r.Delete(ctx, rgCopy)
        }</span>

        <span class="cov6" title="9">createRG := false

        // If the RG already exists on the Remote Cluster,
        // We treat this as idempotent.
        log.V(common.InfoLevel).Info(fmt.Sprintf("Checking if remote RG with the name %s exists on ClusterId: %s",
                remoteRGName, remoteClusterID))
        rgObj, err := remoteClient.GetReplicationGroup(ctx, remoteRGName)
        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                log.Error(err, "failed to get RG details on the remote cluster")
                return ctrl.Result{Requeue: true}, err
        }</span> else<span class="cov6" title="9"> if errors.IsNotFound(err) </span><span class="cov4" title="5">{
                if rgSyncComplete </span><span class="cov0" title="0">{
                        log.Error(err, "Something went wrong. Local RG has already been synced to the remote cluster")
                        // If the RG has been successfully synced to the remote cluster once
                        // and now it's not found,
                        // Let's not recreate the RGs in this case.
                        log.V(common.InfoLevel).Info("RG not found on target cluster. " +
                                "Since the local RG carries a SyncComplete annotation, " +
                                "we will not be creating RG on remote once again.")
                        return ctrl.Result{}, nil
                }</span>
                // This is a special case. Controller tries to endlessly create
                // replicated RGs in single cluster scenario.
                // This check prevents controller from doing that.
                <span class="cov4" title="5">if strings.Contains(remoteRGName, "replicated-replicated") </span><span class="cov0" title="0">{
                        createRG = false
                }</span> else<span class="cov4" title="5"> {
                        createRG = true
                }</span>
        } else<span class="cov4" title="4"> {
                // We got the object
                log.V(common.InfoLevel).Info(" The RG already exists on the remote cluster")
                // First verify the source cluster for this RG
                if rgObj.Spec.RemoteClusterID == localClusterID </span><span class="cov3" title="3">{
                        // Confirmed that this object was created by this controller
                        // Check other fields to see if this matches everything from our object
                        // If fields don't match, then it could mean that this is a leftover object or someone edited it
                        // Verify driver name
                        if rgObj.Spec.DriverName != remoteRG.Spec.DriverName </span><span class="cov1" title="1">{
                                // Lets create a new object
                                remoteRGName = fmt.Sprintf("SourceClusterId-%s-%s", localClusterID, localRGName)
                                remoteRG.Name = remoteRGName
                                createRG = true
                                rgSyncComplete = false
                        }</span> else<span class="cov2" title="2"> {
                                if rgObj.Spec.ProtectionGroupID != remoteRG.Spec.ProtectionGroupID ||
                                        rgObj.Spec.RemoteProtectionGroupID != remoteRG.Spec.RemoteProtectionGroupID </span><span class="cov1" title="1">{
                                        // Don't know how to proceed here
                                        // Lets raise an event and stop reconciling
                                        r.EventRecorder.Eventf(localRG, eventTypeWarning, eventReasonUpdated,
                                                "Found conflicting RG on remote ClusterId: %s", remoteClusterID)
                                        log.Error(fmt.Errorf("conflicting RG with name: %s exists on ClusterId: %s",
                                                localRGName, remoteClusterID), "stopping reconcile")
                                        return ctrl.Result{}, nil
                                }</span>
                        }
                } else<span class="cov1" title="1"> {
                        // update the name of the RG and create it
                        remoteRGName = fmt.Sprintf("SourceClusterId-%s-%s", localClusterID, localRGName)
                        remoteRG.Name = remoteRGName
                        createRG = true
                        rgSyncComplete = false
                }</span>
        }

        <span class="cov5" title="8">if createRG </span><span class="cov5" title="7">{
                err = remoteClient.CreateReplicationGroup(ctx, remoteRG)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to create remote CR for DellCSIReplicationGroup")
                        r.EventRecorder.Eventf(localRG, eventTypeWarning, eventReasonUpdated,
                                "Failed to create remote CR for DellCSIReplicationGroup on ClusterId: %s", remoteClusterID)
                        return ctrl.Result{}, err
                }</span>
                <span class="cov5" title="7">log.V(common.InfoLevel).Info("The remote RG has been successfully created!!")
                r.EventRecorder.Eventf(localRG, eventTypeNormal, eventReasonUpdated,
                        "Created remote ReplicationGroup with name: %s on cluster: %s", remoteRGName, remoteClusterID)</span>
        }

        // Update the RemoteReplicationGroup annotation on the local RG if required
        <span class="cov5" title="8">if !rgSyncComplete </span><span class="cov5" title="7">{
                if strings.Contains(localRGName, replicated) </span><span class="cov0" title="0">{
                        remoteRGName = strings.TrimPrefix(localRGName, "replicated-")
                }</span>
                <span class="cov5" title="7">controller.AddAnnotation(localRG, controller.RemoteReplicationGroup, remoteRGName)
                controller.AddAnnotation(localRG, controller.RGSyncComplete, "yes")
                err = r.Update(ctx, localRG)
                return ctrl.Result{}, err</span>
        }

        <span class="cov1" title="1">err = r.processLastActionResult(ctx, localRG, remoteClient, log)
        if err != nil </span><span class="cov0" title="0">{
                r.EventRecorder.Eventf(localRG, eventTypeWarning, eventReasonUpdated,
                        "failed to process the last action %s", localRG.Status.LastAction.Condition)
        }</span>

        <span class="cov1" title="1">log.V(common.InfoLevel).Info("RG has already been synced to the remote cluster")
        return ctrl.Result{}, nil</span>
}

func (r *ReplicationGroupReconciler) processLastActionResult(ctx context.Context, group *repv1.DellCSIReplicationGroup, remoteClient connection.RemoteClusterClient, log logr.Logger) error <span class="cov5" title="7">{
        if len(group.Status.Conditions) == 0 || group.Status.LastAction.Time == nil </span><span class="cov1" title="1">{
                log.V(common.InfoLevel).Info("No action to process")
                return nil
        }</span>

        <span class="cov5" title="6">if group.Status.LastAction.ErrorMessage != "" </span><span class="cov1" title="1">{
                return fmt.Errorf("last action failed: %s", group.Status.LastAction.Condition)
        }</span>

        <span class="cov4" title="5">val, ok := group.Annotations[controller.ActionProcessedTime]
        if !ok </span><span class="cov1" title="1">{
                log.V(common.InfoLevel).Info("Action Processed does not exist.")
                return nil
        }</span>

        <span class="cov4" title="4">if val == group.Status.LastAction.Time.GoString() </span><span class="cov2" title="2">{
                log.V(common.InfoLevel).Info("Last action has already been processed")
                return nil
        }</span>

        <span class="cov2" title="2">if strings.Contains(group.Status.LastAction.Condition, "CREATE_SNAPSHOT") </span><span class="cov0" title="0">{
                if err := getDellCsiReplicationGroupProcessSnapshotEvent(r, ctx, group, remoteClient, log); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Informing the RG that the last action has been processed.
        <span class="cov2" title="2">controller.AddAnnotation(group, controller.ActionProcessedTime, group.Status.LastAction.Time.GoString())

        return getDellCsiReplicationGroupUpdate(r, ctx, group)</span>
}

func (r *ReplicationGroupReconciler) processSnapshotEvent(ctx context.Context, group *repv1.DellCSIReplicationGroup, remoteClient connection.RemoteClusterClient, log logr.Logger) error <span class="cov6" title="9">{
        lastAction := group.Status.LastAction

        val, ok := group.Annotations[csireplicator.Action]
        if !ok </span><span class="cov2" title="2">{
                log.V(common.InfoLevel).Info("No action", "val", val)
                return nil
        }</span>

        <span class="cov5" title="7">var actionAnnotation csireplicator.ActionAnnotation
        err := json.Unmarshal([]byte(val), &amp;actionAnnotation)
        if err != nil </span><span class="cov1" title="1">{
                log.Error(err, "JSON unmarshal error", "actionAnnotation", actionAnnotation)
                return err
        }</span>

        <span class="cov5" title="6">if _, err := getDellCsiReplicationGroupGetSnapshotClass(remoteClient, ctx, actionAnnotation.SnapshotClass); err != nil </span><span class="cov2" title="2">{
                log.Error(err, "Snapshot class does not exist on remote cluster. Not creating the remote snapshots.")
                return err
        }</span>

        <span class="cov4" title="4">if _, err := getDellCsiReplicationGroupGetNamespace(remoteClient, ctx, actionAnnotation.SnapshotNamespace); err != nil </span><span class="cov2" title="2">{
                log.V(common.InfoLevel).Info("Namespace - " + actionAnnotation.SnapshotNamespace + " not found, creating it.")
                nsRef := makeNamespaceReference(actionAnnotation.SnapshotNamespace)

                err = getDellCsiReplicationGroupCreateNamespace(remoteClient, ctx, nsRef)
                if err != nil </span><span class="cov1" title="1">{
                        msg := "unable to create the desired namespace" + actionAnnotation.SnapshotNamespace
                        log.V(common.ErrorLevel).Error(err, msg)
                        return err
                }</span>
        }

        <span class="cov3" title="3">for volumeHandle, snapshotHandle := range lastAction.ActionAttributes </span><span class="cov3" title="3">{
                msg := "ActionAttributes - volumeHandle: " + volumeHandle + ", snapshotHandle: " + snapshotHandle
                log.V(common.InfoLevel).Info(msg)

                snapRef := makeSnapReference(snapshotHandle, actionAnnotation.SnapshotNamespace)
                sc := makeStorageClassContent(group.Labels[controller.DriverName], actionAnnotation.SnapshotClass)
                snapContent := makeVolSnapContent(snapshotHandle, volumeHandle, *snapRef, sc)

                err = getDellCsiReplicationGroupCreateSnapshotContent(remoteClient, ctx, snapContent)
                if err != nil </span><span class="cov1" title="1">{
                        log.Error(err, "unable to create snapshot content")
                        return err
                }</span>

                <span class="cov2" title="2">snapshot := makeSnapshotObject(snapRef.Name, snapContent.Name, sc.ObjectMeta.Name, actionAnnotation.SnapshotNamespace)
                err = getDellCsiReplicationGroupCreateSnapshotObject(remoteClient, ctx, snapshot)
                if err != nil </span><span class="cov1" title="1">{
                        log.Error(err, "unable to create snapshot object")
                        return err
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

func makeNamespaceReference(namespace string) *v1.Namespace <span class="cov3" title="3">{
        return &amp;v1.Namespace{
                ObjectMeta: metav1.ObjectMeta{
                        Name: namespace,
                },
        }
}</span>

func makeSnapReference(snapName, namespace string) *v1.ObjectReference <span class="cov4" title="4">{
        return &amp;v1.ObjectReference{
                Kind:       "VolumeSnapshot",
                APIVersion: "snapshot.storage.k8s.io/v1",
                Name:       "snapshot-" + snapName,
                Namespace:  namespace,
        }
}</span>

func makeSnapshotObject(snapName, contentName, className, namespace string) *s1.VolumeSnapshot <span class="cov3" title="3">{
        volsnap := &amp;s1.VolumeSnapshot{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      snapName,
                        Namespace: namespace,
                },
                Spec: s1.VolumeSnapshotSpec{
                        Source: s1.VolumeSnapshotSource{
                                VolumeSnapshotContentName: &amp;contentName,
                        },
                        VolumeSnapshotClassName: &amp;className,
                },
        }
        return volsnap
}</span>

func makeStorageClassContent(driver, snapClass string) *s1.VolumeSnapshotClass <span class="cov4" title="4">{
        return &amp;s1.VolumeSnapshotClass{
                Driver:         driver,
                DeletionPolicy: "Retain",
                ObjectMeta: metav1.ObjectMeta{
                        Name: snapClass,
                },
        }
}</span>

func makeVolSnapContent(snapName, volumeName string, snapRef v1.ObjectReference, sc *s1.VolumeSnapshotClass) *s1.VolumeSnapshotContent <span class="cov4" title="4">{
        volsnapcontent := &amp;s1.VolumeSnapshotContent{
                ObjectMeta: metav1.ObjectMeta{
                        Name: "volume-" + volumeName + "-" + strconv.FormatInt(time.Now().Unix(), 10),
                },
                Spec: s1.VolumeSnapshotContentSpec{
                        VolumeSnapshotRef: snapRef,
                        Source: s1.VolumeSnapshotContentSource{
                                SnapshotHandle: &amp;snapName,
                        },
                        VolumeSnapshotClassName: &amp;sc.Name,
                        DeletionPolicy:          sc.DeletionPolicy,
                        Driver:                  sc.Driver,
                },
        }
        return volsnapcontent
}</span>

// SetupWithManager start using reconciler by creating new controller managed by provided manager
func (r *ReplicationGroupReconciler) SetupWithManager(mgr ctrl.Manager, limiter workqueue.TypedRateLimiter[reconcile.Request], maxReconcilers int) error <span class="cov2" title="2">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;repv1.DellCSIReplicationGroup{}).
                WithOptions(reconciler.Options{
                        RateLimiter:             limiter,
                        MaxConcurrentReconciles: maxReconcilers,
                }).
                Complete(r)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
 Copyright Â© 2021-2023 Dell Inc. or its subsidiaries. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package replicationcontroller

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        repv1 "github.com/dell/csm-replication/api/v1"
        controller "github.com/dell/csm-replication/controllers"
        "github.com/dell/csm-replication/pkg/common"
        "github.com/dell/dell-csi-extensions/replication"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/builder"
        "sigs.k8s.io/controller-runtime/pkg/predicate"

        "github.com/dell/csm-replication/pkg/connection"
        reconciler "sigs.k8s.io/controller-runtime/pkg/controller"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"

        "github.com/go-logr/logr"
        v1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/tools/record"
        "k8s.io/client-go/util/workqueue"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

const (
        replicated = "replicated"
)

// PersistentVolumeReconciler reconciles a PersistentVolume object
type PersistentVolumeReconciler struct {
        client.Client
        Log                logr.Logger
        Scheme             *runtime.Scheme
        EventRecorder      record.EventRecorder
        PVCRequeueInterval time.Duration
        Config             connection.MultiClusterClient
        Domain             string
}

var (
        getPersistentVolumeReconcilerUpdate = func(r *PersistentVolumeReconciler, ctx context.Context, obj client.Object) error <span class="cov1" title="1">{
                return r.Update(ctx, obj)
        }</span>
        // getPersistentVolumeReconcilerEventf = func(r *PersistentVolumeReconciler, obj runtime.Object, eventtype string, reason string, messageFmt string, args ...interface{}) {
        getPersistentVolumeReconcilerEventf = func(r *PersistentVolumeReconciler, obj runtime.Object, eventtype string, reason string, messageFmt string, remoteClusterID string) <span class="cov0" title="0">{
                r.EventRecorder.Eventf(obj, eventtype, reason,
                        messageFmt, remoteClusterID)
        }</span>
)

// +kubebuilder:rbac:groups=core,resources=persistentvolumes,verbs=get;update;patch;list;watch;delete

// Reconcile contains reconciliation logic that updates PersistentVolume depending on it's current state
func (r *PersistentVolumeReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="14">{
        log := r.Log.WithValues("persistentvolume", req.Name)
        ctx = context.WithValue(ctx, common.LoggerContextKey, log)

        r.Log.V(common.InfoLevel).Info("Reconciling PV event")

        volume := new(v1.PersistentVolume)
        if err := r.Get(ctx, req.NamespacedName, volume); err != nil </span><span class="cov2" title="2">{
                return ctrl.Result{}, client.IgnoreNotFound(err)
        }</span>

        // First get the required fields from PVC
        <span class="cov7" title="12">localPVName := volume.Name
        // Lets start with the assumption that remote PV name is same as local PV
        remotePVName := localPVName

        log.V(common.DebugLevel).Info("Fetching details from the PV object")

        // Parse the local annotations
        localAnnotations := volume.Annotations

        // RemoteClusterID annotation
        remoteClusterID, err := getValueFromAnnotations(controller.RemoteClusterID, localAnnotations)
        if err != nil </span><span class="cov1" title="1">{
                log.Error(err, "remoteClusterID not set")
                r.EventRecorder.Eventf(volume, eventTypeWarning, eventReasonUpdated,
                        "failed to fetch remote cluster id from annotations. error: %s", err.Error())
                return ctrl.Result{}, err
        }</span>

        // For single cluster, the remote clusterID is 'self'
        // For this special case, we prefix the PV with 'replicated' keyword
        // in order to allow a replicated PV to exist on the source
        // cluster itself
        <span class="cov7" title="11">if remoteClusterID == controller.Self </span><span class="cov1" title="1">{
                remotePVName = replicated + "-" + localPVName
        }</span>

        // Get the remote client
        <span class="cov7" title="11">rClient, err := r.Config.GetConnection(remoteClusterID)
        if err != nil </span><span class="cov2" title="2">{
                return ctrl.Result{}, err
        }</span>

        // Check for volume retention policy annotation
        <span class="cov6" title="9">retentionPolicy, ok := volume.Annotations[controller.RemotePVRetentionPolicy]
        if !ok </span><span class="cov6" title="7">{
                log.V(common.InfoLevel).Info("Retention policy not set, using retain as the default policy")
                retentionPolicy = "retain" // we will default to retain the PV if there is no retention policy is set
        }</span>

        // Handle PV deletion if timestamp is set
        <span class="cov6" title="9">if !volume.DeletionTimestamp.IsZero() </span><span class="cov1" title="1">{
                // Process deletion of remote PV
                if _, ok := volume.Annotations[controller.DeletionRequested]; !ok </span><span class="cov1" title="1">{
                        log.V(common.InfoLevel).Info("Deletion requested annotation not found")
                        remoteVolume, err := rClient.GetPersistentVolume(ctx, volume.Annotations[controller.RemotePV])
                        if err != nil </span><span class="cov0" title="0">{
                                // If remote PV doesn't exist, proceed to removing finalizer
                                if !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                        log.Error(err, "Failed to get remote volume")
                                        return ctrl.Result{}, err
                                }</span>
                        } else<span class="cov1" title="1"> {
                                log.V(common.DebugLevel).Info("Got remote PV")
                                if retentionPolicy == "delete" </span><span class="cov1" title="1">{
                                        log.V(common.InfoLevel).Info("Retention policy is set to Delete")
                                        if _, ok := remoteVolume.Annotations[controller.DeletionRequested]; !ok </span><span class="cov1" title="1">{
                                                // Add annotation on the remote PV to request its deletion
                                                remoteVolumeCopy := remoteVolume.DeepCopy()
                                                log.V(common.InfoLevel).Info("Adding deletion requested annotation to remote volume")
                                                controller.AddAnnotation(remoteVolumeCopy, controller.DeletionRequested, "yes")

                                                // also apply new annotation - SynchronizedDeletionStatus
                                                log.V(common.InfoLevel).Info("Adding sync delete annotation to remote")
                                                controller.AddAnnotation(remoteVolumeCopy, controller.SynchronizedDeletionStatus, "requested")
                                                err := rClient.UpdatePersistentVolume(ctx, remoteVolumeCopy)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        log.V(common.InfoLevel).Info("Error encountered in updating remote volume")
                                                        return ctrl.Result{}, err
                                                }</span>

                                                // Resetting the rate-limiter to requeue for the deletion of remote PV
                                                <span class="cov1" title="1">return ctrl.Result{RequeueAfter: 1 * time.Millisecond}, nil</span>
                                        }
                                        // Requeueing local PV because the remote PV still exists.
                                        <span class="cov0" title="0">return ctrl.Result{Requeue: true}, nil</span>
                                }
                        }
                }

                // Check for the sync deletion annotation. If it exists and is not complete, requeue.
                // Otherwise, remove finalizer.
                <span class="cov0" title="0">syncDeleteStatus, ok := volume.Annotations[controller.SynchronizedDeletionStatus]
                if ok &amp;&amp; syncDeleteStatus != "complete" </span><span class="cov0" title="0">{
                        log.V(common.InfoLevel).Info("Synchronized Deletion annotation exists and is not complete, requeueing.")
                        return ctrl.Result{Requeue: true}, nil
                }</span>

                <span class="cov0" title="0">log.V(common.InfoLevel).Info("Removing finalizer on local volume")
                finalizerRemoved := controller.RemoveFinalizerIfExists(volume, controller.ReplicationFinalizer)
                if finalizerRemoved </span><span class="cov0" title="0">{
                        return ctrl.Result{}, r.Update(ctx, volume)
                }</span>
        }

        <span class="cov6" title="8">volumeCopy := volume.DeepCopy()

        // Check for the finalizer; add, if doesn't exist
        if finalizerAdded := controller.AddFinalizerIfNotExist(volumeCopy, controller.ReplicationFinalizer); finalizerAdded </span><span class="cov1" title="1">{
                log.V(common.DebugLevel).Info("Finalizer not found, adding it")
                return ctrl.Result{}, r.Update(ctx, volumeCopy)
        }</span>
        // Check for deletion request annotation.
        <span class="cov6" title="7">if _, ok := volumeCopy.Annotations[controller.DeletionRequested]; ok </span><span class="cov0" title="0">{
                log.V(common.InfoLevel).Info("Deletion Requested by remote's controller, annotation found")
                return ctrl.Result{}, r.Delete(ctx, volumeCopy)
        }</span>

        <span class="cov6" title="7">_, ok = volume.Annotations[controller.PVProtectionComplete]
        if ok </span><span class="cov6" title="7">{
                // RemotePV Annotation
                remotePVAnnotationSet := false
                if localAnnotations[controller.RemotePV] != "" </span><span class="cov5" title="5">{
                        // We have already reconciled this in the past
                        // Lets verify again if everything is proper
                        remotePVAnnotationSet = true
                        // Update the remote PV name to point to the one in annotation
                        remotePVName = localAnnotations[controller.RemotePV]
                        log.V(common.DebugLevel).Info("Remote PV annotation already set. Verifying details")
                }</span>

                // RemoteVolumeAnnotation
                <span class="cov6" title="7">var remoteVolumeDetails replication.Volume
                var volumeHandle string
                if _, ok := volume.Annotations[controller.CreatedBy]; !ok </span><span class="cov6" title="7">{
                        err = json.Unmarshal([]byte(volume.Annotations[controller.RemoteVolumeAnnotation]), &amp;remoteVolumeDetails)
                        if err != nil </span><span class="cov1" title="1">{
                                log.Error(err, "Failed to unmarshal json for remote volume details")
                                return ctrl.Result{}, err
                        }</span>

                        <span class="cov5" title="6">volumeHandle = remoteVolumeDetails.VolumeId
                        if volumeHandle == "" </span><span class="cov1" title="1">{
                                volHandleErr := fmt.Errorf("volume_id missing from the remote volume annotation")
                                log.Error(volHandleErr, "unexpected error")
                                r.EventRecorder.Eventf(volume, eventTypeWarning, eventReasonUpdated, "%s", volHandleErr.Error())
                                return ctrl.Result{}, volHandleErr
                        }</span>
                }

                // RemoteStorageClass Annotation
                <span class="cov5" title="5">remoteSCName, err := getValueFromAnnotations(controller.RemoteStorageClassAnnotation, localAnnotations)
                if err != nil </span><span class="cov1" title="1">{
                        log.Error(err, "failed to fetch remote storage class name")
                        r.EventRecorder.Eventf(volume, eventTypeWarning, eventReasonUpdated,
                                "failed to fetch remote storage class name from annotations. error: %s", err.Error())
                        return ctrl.Result{}, err
                }</span>

                // ReplicationGroup Annotation
                <span class="cov4" title="4">localRGName, err := getValueFromAnnotations(controller.ReplicationGroup, localAnnotations)
                if err != nil </span><span class="cov1" title="1">{
                        log.Error(err, "failed to fetch local replication group name")
                        r.EventRecorder.Eventf(volume, eventTypeWarning, eventReasonUpdated,
                                "failed to fetch local replication group name from annotations. error: %s", err.Error())
                        return ctrl.Result{}, err
                }</span>

                // Check if remote SC exists
                <span class="cov3" title="3">remoteSC, err := rClient.GetStorageClass(ctx, remoteSCName)
                if err != nil &amp;&amp; errors.IsNotFound(err) </span><span class="cov1" title="1">{
                        // Log an event and throw the error
                        log.Error(err, "remote storage class doesn't exist")
                        r.EventRecorder.Eventf(volume, eventTypeWarning, eventReasonUpdated,
                                "remote storage class: %s doesn't exist on cluster: %s. error: %s",
                                remoteSCName, remoteClusterID, err.Error())
                        return ctrl.Result{}, err
                }</span> else<span class="cov2" title="2"> if err != nil </span><span class="cov0" title="0">{
                        // This could be transient. So, throw an error
                        log.Error(err, "failed to fetch remote storage class")
                        return ctrl.Result{}, err
                }</span>

                <span class="cov2" title="2">var localClusterID string
                if remoteClusterID == controller.Self </span><span class="cov0" title="0">{
                        localClusterID = controller.Self
                }</span> else<span class="cov2" title="2"> {
                        localClusterID = r.Config.GetClusterID()
                }</span>

                <span class="cov2" title="2">pv := &amp;v1.PersistentVolume{
                        ObjectMeta: metav1.ObjectMeta{
                                Name:       remotePVName,
                                Finalizers: []string{controller.ReplicationFinalizer},
                        },
                        Spec: v1.PersistentVolumeSpec{
                                PersistentVolumeSource: v1.PersistentVolumeSource{CSI: &amp;v1.CSIPersistentVolumeSource{
                                        Driver:           remoteSC.Provisioner,
                                        VolumeHandle:     volumeHandle,
                                        VolumeAttributes: remoteVolumeDetails.GetVolumeContext(),
                                }},
                                Capacity:                      volume.Spec.Capacity,
                                AccessModes:                   volume.Spec.AccessModes,
                                VolumeMode:                    volume.Spec.VolumeMode,
                                StorageClassName:              remoteSCName,
                                PersistentVolumeReclaimPolicy: *remoteSC.ReclaimPolicy,
                        },
                }

                // Update Labels for remote PV
                updatePVLabels(pv, volume, localClusterID)

                // Add driver specific labels
                contextPrefix := volume.Annotations[controller.ContextPrefix]
                if contextPrefix != "" </span><span class="cov2" title="2">{
                        for k, v := range remoteVolumeDetails.GetVolumeContext() </span><span class="cov8" title="16">{
                                if strings.HasPrefix(k, contextPrefix) </span><span class="cov5" title="6">{
                                        labelKey := fmt.Sprintf("%s%s", r.Domain, strings.TrimPrefix(k, contextPrefix))
                                        controller.AddLabel(pv, labelKey, fmt.Sprintf("%v", v))
                                }</span>
                        }
                }

                <span class="cov2" title="2">var resourceRequests []byte

                if volume.Spec.ClaimRef != nil </span><span class="cov2" title="2">{
                        pvc := new(v1.PersistentVolumeClaim)
                        if err := r.Get(ctx, client.ObjectKey{
                                Namespace: volume.Spec.ClaimRef.Namespace,
                                Name:      volume.Spec.ClaimRef.Name,
                        }, pvc); err != nil </span><span class="cov0" title="0">{
                                return ctrl.Result{}, err
                        }</span>

                        <span class="cov2" title="2">resourceRequests, err = json.Marshal(pvc.Spec.Resources.Requests)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "Unable to marshal PVC Resource requests")
                                return ctrl.Result{}, err
                        }</span>

                }

                <span class="cov2" title="2">updatePVAnnotations(pv, volume, localClusterID, localAnnotations[controller.RemotePVRetentionPolicy], string(resourceRequests))

                // Query local RG object to verify if RemoteReplicationGroup annotation is available
                localRG := new(repv1.DellCSIReplicationGroup)
                err = r.Get(ctx, types.NamespacedName{Name: localRGName}, localRG)
                if err != nil </span><span class="cov0" title="0">{
                        // Requeue
                        return ctrl.Result{}, err
                }</span>

                <span class="cov2" title="2">remoteRGName, err := getValueFromAnnotations(controller.RemoteReplicationGroup, localRG.Annotations)
                if err != nil </span><span class="cov0" title="0">{
                        // We can still continue as we can always requeue the request
                        log.V(common.DebugLevel).Info("Remote RG annotation has not been set on the local RG")
                }</span> else<span class="cov2" title="2"> {
                        // Update the annotation for the remote PV object
                        controller.AddAnnotation(pv, controller.ReplicationGroup, remoteRGName)
                        controller.AddLabel(pv, controller.ReplicationGroup, remoteRGName)
                }</span>

                <span class="cov2" title="2">log.V(common.DebugLevel).Info("Checking if the PV already exists " + remotePVName)
                remotePV, err := rClient.GetPersistentVolume(ctx, remotePVName)
                createRemotePV := false
                if err != nil &amp;&amp; errors.IsNotFound(err) </span><span class="cov1" title="1">{
                        if remotePVAnnotationSet </span><span class="cov1" title="1">{
                                // This is unexpected as the RemotePV annotation indicates that the remote PV should be created
                                log.Error(err, "Something went wrong. Remote PV annotation already set")
                                log.V(common.InfoLevel).Info("Creating the remote PV again")
                        }</span>
                        <span class="cov1" title="1">createRemotePV = true</span>
                } else<span class="cov1" title="1"> if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to check if remote PV exists")
                        return ctrl.Result{}, err
                }</span>

                <span class="cov2" title="2">if createRemotePV </span><span class="cov1" title="1">{
                        // We need to create the PV
                        err = rClient.CreatePersistentVolume(ctx, pv)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "Failed to create remote PV on target cluster")
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov1" title="1">log.V(common.InfoLevel).Info(fmt.Sprintf("Successfully created the remote PV with name: %s on cluster: %s",
                                remotePVName, remoteClusterID))
                        r.EventRecorder.Eventf(volume, eventTypeNormal, eventReasonUpdated,
                                "Created Remote PV with name: %s on cluster: %s", remotePVName, remoteClusterID)
                        // fetch the newly created PV object
                        remotePV, err = rClient.GetPersistentVolume(ctx, remotePVName)
                        if err != nil </span><span class="cov0" title="0">{
                                return ctrl.Result{}, err
                        }</span>
                } else<span class="cov1" title="1"> {
                        // Remote PV already exists
                        // TODO: Verify if the Remote PV matches with the one we are expecting

                        // For now just verify if the cluster id matches
                        if remotePV.Annotations[controller.RemoteClusterID] != localClusterID </span><span class="cov1" title="1">{
                                // This PV was created by someone else
                                // For now, lets just raise an event and stop the reconcile
                                log.Error(fmt.Errorf("conflicting PV with name: %s exists on ClusterId: %s",
                                        remotePVName, remoteClusterID), "stopping reconcile")
                                r.EventRecorder.Eventf(volume, eventTypeWarning, eventReasonUpdated,
                                        "Found conflicting PV %s on remote ClusterId: %s", remotePVName, remoteClusterID)
                                return ctrl.Result{}, nil
                        }</span>
                }

                // Get the local PV object
                <span class="cov1" title="1">localPV := v1.PersistentVolume{}
                err = r.Get(ctx, types.NamespacedName{Name: localPVName}, &amp;localPV)
                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>

                // Now update the remote PV with RemoteReplicationGroup annotation if required
                <span class="cov1" title="1">requeue, err := r.processRemotePV(ctx, rClient, remotePV, remoteRGName)
                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
                <span class="cov1" title="1">if requeue </span><span class="cov0" title="0">{
                        return ctrl.Result{RequeueAfter: controller.DefaultRetryInterval}, nil
                }</span>

                <span class="cov1" title="1">err = r.processLocalPV(ctx, localPV.DeepCopy(), remotePVName, remoteClusterID)
                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov1" title="1">log.V(common.InfoLevel).Info("PV Reconcile complete!!!!!")
                return ctrl.Result{}, nil</span>
        }

        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

func (r *PersistentVolumeReconciler) processRemotePV(ctx context.Context,
        rClient connection.RemoteClusterClient, remotePV *v1.PersistentVolume, remoteRGName string,
) (bool, error) <span class="cov5" title="5">{
        log := common.GetLoggerFromContext(ctx)
        if remoteRGName != "" </span><span class="cov3" title="3">{
                // Update the annotation for the remote PV object
                // controller.AddAnnotation(remotePV, controller.ReplicationGroup, remoteRGName)
                if remotePV.Annotations[controller.ReplicationGroup] == "" </span><span class="cov1" title="1">{
                        // Set the annotation
                        log.V(common.DebugLevel).Info(fmt.Sprintf("Setting the ReplicationGroup label &amp; annotation %s on remotePV %s", remoteRGName, remotePV.Name))
                        controller.AddAnnotation(remotePV, controller.ReplicationGroup, remoteRGName)
                        controller.AddLabel(remotePV, controller.ReplicationGroup, remoteRGName)
                        err := rClient.UpdatePersistentVolume(ctx, remotePV)
                        if err != nil </span><span class="cov1" title="1">{
                                return true, err
                        }</span>
                } else<span class="cov2" title="2"> {
                        log.V(common.DebugLevel).Info("ReplicationGroup Annotation already set")
                }</span>
                <span class="cov2" title="2">return false, nil</span>
        }
        <span class="cov2" title="2">return true, nil</span>
}

func (r *PersistentVolumeReconciler) processLocalPV(ctx context.Context, localPV *v1.PersistentVolume, remotePVName, remoteClusterID string) error <span class="cov4" title="4">{
        log := common.GetLoggerFromContext(ctx)
        // Update the local PV with the remote details
        // First check if the PV sync has been completed
        if localPV.Annotations[controller.PVSyncComplete] == "yes" </span><span class="cov1" title="1">{
                log.V(common.InfoLevel).Info("PV has already been synced")
                return nil
        }</span>
        <span class="cov3" title="3">updatePV := false
        remotePVNameFromLocalPVAnnotation := localPV.Annotations[controller.RemotePV]
        remoteClusterIDFromLocalPVAnnotation := localPV.Annotations[controller.RemoteClusterID]

        if remotePVNameFromLocalPVAnnotation == "" </span><span class="cov2" title="2">{
                controller.AddAnnotation(localPV, controller.RemotePV, remotePVName)
                updatePV = true
                // } else if remotePVNameFromLocalPVAnnotation != remotePVName {
                // Conflict - ??
        }</span> else<span class="cov1" title="1"> {
                log.V(common.InfoLevel).Info(fmt.Sprintf("%s already set to %s for local PV: %s",
                        controller.RemotePV, remotePVNameFromLocalPVAnnotation, localPV.Name))
        }</span>

        <span class="cov3" title="3">if remoteClusterIDFromLocalPVAnnotation == "" </span><span class="cov2" title="2">{
                controller.AddAnnotation(localPV, controller.RemoteClusterID, remoteClusterID)
                updatePV = true
                // } else if remoteClusterIDFromLocalPVAnnotation != remoteClusterID {
                // Conflict - ??
        }</span> else<span class="cov1" title="1"> {
                log.V(common.InfoLevel).Info(fmt.Sprintf("%s already set to %s for local PV: %s",
                        controller.RemoteClusterID, remoteClusterIDFromLocalPVAnnotation, localPV.Name))
        }</span>

        <span class="cov3" title="3">if updatePV </span><span class="cov2" title="2">{
                // Finally add the PV sync complete annotation
                controller.AddAnnotation(localPV, controller.PVSyncComplete, "yes")
                err := getPersistentVolumeReconcilerUpdate(r, ctx, localPV)
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov1" title="1">log.V(common.InfoLevel).Info("Successfully updated local PV with remote annotations")
                // r.EventRecorder.Eventf(localPV, eventTypeNormal, eventReasonUpdated,
                //         "PV sync complete for ClusterId: %s", remoteClusterID)
                getPersistentVolumeReconcilerEventf(r, localPV, eventTypeNormal, eventReasonUpdated,
                        "PV sync complete for ClusterId: %s", remoteClusterID)</span>
        }
        <span class="cov2" title="2">return nil</span>
}

// SetupWithManager start using reconciler by creating new controller managed by provided manager
func (r *PersistentVolumeReconciler) SetupWithManager(mgr ctrl.Manager, limiter workqueue.TypedRateLimiter[reconcile.Request], maxReconcilers int) error <span class="cov1" title="1">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;v1.PersistentVolume{}, builder.WithPredicates(
                        predicate.Or(
                                pvProtectionIsComplete(),
                                hasDeletionTimestamp(),
                                isDeletionRequested(),
                        ),
                )).WithOptions(reconciler.Options{
                RateLimiter:             limiter,
                MaxConcurrentReconciles: maxReconcilers,
        }).
                Complete(r)
}</span>

// External function variables
var (
        newPredicateFuncs = predicate.NewPredicateFuncs
        getAnnotations    = func(meta client.Object) map[string]string <span class="cov2" title="2">{
                return meta.GetAnnotations()
        }</span>
        getDeletionTimestamp = func(meta client.Object) *metav1.Time <span class="cov2" title="2">{
                return meta.GetDeletionTimestamp()
        }</span>
)

// pvProtectionIsComplete checks if the PV protection is complete based on annotations.
func pvProtectionIsComplete() predicate.Predicate <span class="cov4" title="4">{
        return newPredicateFuncs(func(meta client.Object) bool </span><span class="cov3" title="3">{
                a := getAnnotations(meta)
                return a != nil &amp;&amp; a[controller.PVProtectionComplete] == "yes"
        }</span>)
}

func hasDeletionTimestamp() predicate.Predicate <span class="cov3" title="3">{
        return newPredicateFuncs(func(meta client.Object) bool </span><span class="cov2" title="2">{
                return getDeletionTimestamp(meta) != nil
        }</span>)
}

func isDeletionRequested() predicate.Predicate <span class="cov4" title="4">{
        return newPredicateFuncs(func(meta client.Object) bool </span><span class="cov3" title="3">{
                a := getAnnotations(meta)
                return a != nil &amp;&amp; a[controller.DeletionRequested] == "yes"
        }</span>)
}

func getValueFromAnnotations(key string, annotations map[string]string) (string, error) <span class="cov10" title="28">{
        if val, ok := annotations[key]; ok </span><span class="cov9" title="25">{
                if val == "" </span><span class="cov1" title="1">{
                        return "", fmt.Errorf("missing value for %s", key)
                }</span>
                <span class="cov9" title="24">return val, nil</span>
        }
        <span class="cov3" title="3">return "", fmt.Errorf("not set")</span>
}

func updatePVAnnotations(pv, volume *v1.PersistentVolume, remoteClusterID, remotePVRetentionPolicy, resourceRequest string) <span class="cov2" title="2">{
        if volume.Spec.CSI != nil </span><span class="cov2" title="2">{
                controller.AddAnnotation(pv, "pv.kubernetes.io/provisioned-by", volume.Spec.CSI.Driver)
        }</span>
        // Created By
        <span class="cov2" title="2">controller.AddAnnotation(pv, controller.CreatedBy, common.DellReplicationController)
        // Remote PV Name
        controller.AddAnnotation(pv, controller.RemotePV, volume.Name)

        if volume.Spec.ClaimRef != nil </span><span class="cov2" title="2">{
                // Remote PVC Name
                controller.AddAnnotation(pv, controller.RemotePVC, volume.Spec.ClaimRef.Name)
                // Remote PVC Namespace
                controller.AddAnnotation(pv, controller.RemotePVCNamespace, volume.Spec.ClaimRef.Namespace)
        }</span>
        // Remote ClusterID
        <span class="cov2" title="2">controller.AddAnnotation(pv, controller.RemoteClusterID, remoteClusterID)
        // Remote Storage Class
        controller.AddAnnotation(pv, controller.RemoteStorageClassAnnotation, volume.Spec.StorageClassName)
        // Resource Requests
        if resourceRequest != "" </span><span class="cov2" title="2">{
                controller.AddAnnotation(pv, controller.ResourceRequest, resourceRequest)
        }</span>
        // RemotePVRetentionPolicy
        <span class="cov2" title="2">controller.AddAnnotation(pv, controller.RemotePVRetentionPolicy, remotePVRetentionPolicy)</span>
}

func updatePVLabels(pv, volume *v1.PersistentVolume, remoteClusterID string) <span class="cov2" title="2">{
        // Driver Name
        controller.AddLabel(pv, controller.DriverName, volume.Labels[controller.DriverName])
        // Remote ClusterID
        controller.AddLabel(pv, controller.RemoteClusterID, remoteClusterID)
        // Remote PVC Namespace
        if volume.Spec.ClaimRef != nil </span><span class="cov2" title="2">{
                controller.AddLabel(pv, controller.RemotePVCNamespace, volume.Spec.ClaimRef.Namespace)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
 Copyright Â© 2021-2023 Dell Inc. or its subsidiaries. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
      http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package replicationcontroller

import (
        "context"
        "time"

        controller "github.com/dell/csm-replication/controllers"
        "github.com/dell/csm-replication/pkg/common"
        v1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        "sigs.k8s.io/controller-runtime/pkg/builder"
        reconciler "sigs.k8s.io/controller-runtime/pkg/controller"
        "sigs.k8s.io/controller-runtime/pkg/predicate"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"

        "github.com/dell/csm-replication/pkg/connection"
        "github.com/go-logr/logr"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/tools/record"
        "k8s.io/client-go/util/workqueue"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// PersistentVolumeClaimReconciler reconciles a PersistentVolumeClaim object
type PersistentVolumeClaimReconciler struct {
        client.Client
        Log                logr.Logger
        Scheme             *runtime.Scheme
        EventRecorder      record.EventRecorder
        PVCRequeueInterval time.Duration
        Config             connection.MultiClusterClient
        Domain             string
}

var (
        getPersistentVolumeClaimUpdatePersistentVolumeClaim = func(r connection.RemoteClusterClient, ctx context.Context, claim *v1.PersistentVolumeClaim) error <span class="cov1" title="1">{
                return r.UpdatePersistentVolumeClaim(ctx, claim)
        }</span>
        getPersistentVolumeClaimUpdate = func(r *PersistentVolumeClaimReconciler, ctx context.Context, claim *v1.PersistentVolumeClaim) error <span class="cov6" title="3">{
                return r.Update(ctx, claim)
        }</span>
        getPersistentVolumeClaimReconcilerEventf = func(r *PersistentVolumeClaimReconciler, claim *v1.PersistentVolumeClaim, eventTypeNormal string, eventReasonUpdated string, message string, remoteClusterID string) <span class="cov0" title="0">{
                r.EventRecorder.Eventf(claim, eventTypeNormal, eventReasonUpdated,
                        message, remoteClusterID)
        }</span>
)

// +kubebuilder:rbac:groups=core,resources=persistentvolumeclaims,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=core,resources=persistentvolumeclaims/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=core,resources=persistentvolumes,verbs=get;update;patch;list;watch;create
// +kubebuilder:rbac:groups=core,resources=events,verbs=list;watch;create;update;patch
// +kubebuilder:rbac:groups=storage.k8s.io,resources=storageclasses,verbs=get;list;watch

// Reconcile contains reconciliation logic that updates PersistentVolumeClaim depending on it's current state
func (r *PersistentVolumeClaimReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov10" title="6">{
        // If we have received the reconcile request, it means that the sidecar has completed its protection
        log := r.Log.WithValues("persistentvolumeclaim", req.NamespacedName)
        ctx = context.WithValue(ctx, common.LoggerContextKey, log)

        claim := new(v1.PersistentVolumeClaim)
        err := r.Get(ctx, req.NamespacedName, claim)
        if err != nil &amp;&amp; errors.IsNotFound(err) </span><span class="cov1" title="1">{
                return ctrl.Result{}, client.IgnoreNotFound(err)
        }</span> else<span class="cov9" title="5"> if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        // First get the required fields from PVC
        <span class="cov9" title="5">localPVName := claim.Spec.VolumeName
        // Lets start with the assumption that remote PV name is same as local PV
        remotePVName := localPVName

        log.V(common.InfoLevel).Info("Reconciling PVC event!!!")

        // Parse the local annotations
        localAnnotations := claim.Annotations

        // RemoteClusterID annotation
        remoteClusterID, err := getValueFromAnnotations(controller.RemoteClusterID, localAnnotations)
        if err != nil </span><span class="cov1" title="1">{
                log.Error(err, "remoteClusterID not set")
                r.EventRecorder.Eventf(claim, eventTypeWarning, eventReasonUpdated,
                        "failed to fetch remote cluster id from annotations. error: %s", err.Error())
                return ctrl.Result{}, err
        }</span>

        // For single cluster, the remote clusterID is 'self'
        // For this special case, we prefix the PV with 'self' keyword
        // in order to allow a replicated PV to exist on the source
        // cluster itself
        <span class="cov7" title="4">if remoteClusterID == controller.Self </span><span class="cov0" title="0">{
                remotePVName = replicated + "-" + localPVName
        }</span>

        // Get the remote client
        <span class="cov7" title="4">rClient, err := r.Config.GetConnection(remoteClusterID)
        if err != nil </span><span class="cov1" title="1">{
                return ctrl.Result{}, err
        }</span>

        // RemotePV Annotation
        <span class="cov6" title="3">remotePVAnnotationSet := false
        if localAnnotations[controller.RemotePV] != "" </span><span class="cov4" title="2">{
                // We have already reconciled this in the past
                // Lets verify again if everything is proper
                remotePVAnnotationSet = true
                // Update the remote PV name to point to the one in annotation
                remotePVName = localAnnotations[controller.RemotePV]
                log.V(common.DebugLevel).Info("Remote PV annotation already set. Verifying details")
        }</span>

        <span class="cov6" title="3">log.V(common.DebugLevel).Info("Checking if the PV already exists " + remotePVName)
        remotePV, err := rClient.GetPersistentVolume(ctx, remotePVName)
        if err != nil &amp;&amp; errors.IsNotFound(err) </span><span class="cov1" title="1">{
                if remotePVAnnotationSet </span><span class="cov1" title="1">{
                        // This is unexpected as the RemotePV annotation indicates that the remote PV should be created
                        log.Error(err, "Something went wrong. Remote PV annotation already set")
                        return ctrl.Result{}, err
                }</span>
                <span class="cov0" title="0">log.V(common.InfoLevel).Info("Will wait for remote PV to be created...")
                return ctrl.Result{RequeueAfter: controller.DefaultRetryInterval}, nil</span>
        } else<span class="cov4" title="2"> if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to check if remote PV exists")
                return ctrl.Result{}, err
        }</span>

        // Get the remote PVC object
        <span class="cov4" title="2">remoteClaim := &amp;v1.PersistentVolumeClaim{}
        remotePVCName := ""
        remotePVCNamespace := ""
        if remotePV.Status.Phase == v1.VolumeBound &amp;&amp; remotePV.Spec.ClaimRef != nil </span><span class="cov0" title="0">{
                remotePVCName = remotePV.Spec.ClaimRef.Name
                remotePVCNamespace = remotePV.Spec.ClaimRef.Namespace
                remoteClaim, err = rClient.GetPersistentVolumeClaim(ctx, remotePVCNamespace, remotePVCName)
                if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
        } else<span class="cov4" title="2"> {
                remoteClaim = nil
        }</span>

        <span class="cov4" title="2">isRemotePVCUpdated := false
        if remoteClaim != nil </span><span class="cov0" title="0">{
                // Update the remote PVC if it exists
                isRemotePVCUpdated, err = r.processRemotePVC(ctx, rClient, remoteClaim, req.Name, req.Namespace, localPVName)
                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
        } else<span class="cov4" title="2"> {
                log.V(common.InfoLevel).Info("Remote PVC has not been created yet. Information can't be synced")
        }</span>

        <span class="cov4" title="2">err = r.processLocalPVC(ctx, claim, remotePVName, remotePVCName, remotePVCNamespace, remoteClusterID, isRemotePVCUpdated)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        <span class="cov4" title="2">log.V(common.InfoLevel).Info("PVC Reconcile complete!!!!")
        return ctrl.Result{}, nil</span>
}

func (r *PersistentVolumeClaimReconciler) processRemotePVC(ctx context.Context,
        rClient connection.RemoteClusterClient,
        claim *v1.PersistentVolumeClaim,
        remotePVCName, remotePVCNamespace, remotePVName string,
) (bool, error) <span class="cov6" title="3">{
        log := common.GetLoggerFromContext(ctx)
        isUpdated := false
        // Just apply the missing annotation
        if claim.Annotations[controller.RemotePVC] == "" </span><span class="cov4" title="2">{
                claim.Annotations[controller.RemotePVC] = remotePVCName
                isUpdated = true
        }</span>
        <span class="cov6" title="3">if claim.Annotations[controller.RemotePVCNamespace] == "" </span><span class="cov1" title="1">{
                claim.Annotations[controller.RemotePVCNamespace] = remotePVCNamespace
                isUpdated = true
        }</span>
        <span class="cov6" title="3">if claim.Annotations[controller.RemotePV] == "" </span><span class="cov1" title="1">{
                claim.Annotations[controller.RemotePV] = remotePVName
                isUpdated = true
        }</span>
        <span class="cov6" title="3">if isUpdated </span><span class="cov4" title="2">{
                err := getPersistentVolumeClaimUpdatePersistentVolumeClaim(rClient, ctx, claim)
                if err != nil </span><span class="cov1" title="1">{
                        return false, err
                }</span>
                <span class="cov1" title="1">log.V(common.InfoLevel).Info("Successfully updated remote PVC with annotation")
                return true, nil</span>
        }

        <span class="cov1" title="1">log.V(common.InfoLevel).Info("Remote PVC already has the annotations set")
        return true, nil</span>
}

func (r *PersistentVolumeClaimReconciler) processLocalPVC(ctx context.Context,
        claim *v1.PersistentVolumeClaim, remotePVName, remotePVCName, remotePVCNamespace,
        remoteClusterID string, isRemotePVCUpdated bool,
) error <span class="cov9" title="5">{
        log := common.GetLoggerFromContext(ctx)
        if claim.Annotations[controller.PVCSyncComplete] == "yes" </span><span class="cov1" title="1">{
                log.V(common.InfoLevel).Info("PVC Sync already completed")
                return nil
        }</span>
        // Apply the remote PV annotation if required
        <span class="cov7" title="4">if claim.Annotations[controller.RemotePV] == "" </span><span class="cov4" title="2">{
                controller.AddAnnotation(claim, controller.RemotePV, remotePVName)
        }</span>
        // Apply the remotePVC name and remotePVCNamespace annotation
        <span class="cov7" title="4">if claim.Annotations[controller.RemotePVC] == "" &amp;&amp; remotePVCName != "" </span><span class="cov1" title="1">{
                controller.AddAnnotation(claim, controller.RemotePVC, remotePVCName)
        }</span>
        <span class="cov7" title="4">if claim.Annotations[controller.RemotePVCNamespace] == "" &amp;&amp; remotePVCNamespace != "" </span><span class="cov1" title="1">{
                controller.AddAnnotation(claim, controller.RemotePVCNamespace, remotePVCNamespace)
        }</span>

        <span class="cov7" title="4">if isRemotePVCUpdated </span><span class="cov4" title="2">{
                controller.AddAnnotation(claim, controller.PVCSyncComplete, "yes")
        }</span>
        // err := r.Update(ctx, claim)
        <span class="cov7" title="4">err := getPersistentVolumeClaimUpdate(r, ctx, claim)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov6" title="3">if isRemotePVCUpdated </span><span class="cov1" title="1">{
                // r.EventRecorder.Eventf(claim, eventTypeNormal, eventReasonUpdated,
                //         "PVC sync complete for ClusterId: %s", remoteClusterID)
                getPersistentVolumeClaimReconcilerEventf(r, claim, eventTypeNormal, eventReasonUpdated,
                        "PV sync complete for ClusterId: %s", remoteClusterID)
        }</span>
        <span class="cov6" title="3">return nil</span>
}

// SetupWithManager start using reconciler by creating new controller managed by provided manager
func (r *PersistentVolumeClaimReconciler) SetupWithManager(mgr ctrl.Manager, limiter workqueue.TypedRateLimiter[reconcile.Request], maxReconcilers int) error <span class="cov1" title="1">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;v1.PersistentVolumeClaim{}, builder.WithPredicates(
                        predicate.And(
                                pvcProtectionIsComplete(),
                        ),
                )).WithOptions(reconciler.Options{
                MaxConcurrentReconciles: maxReconcilers,
                RateLimiter:             limiter,
        }).Complete(r)
}</span>

func pvcProtectionIsComplete() predicate.Predicate <span class="cov7" title="4">{
        return newPredicateFuncs(func(meta client.Object) bool </span><span class="cov6" title="3">{
                a := getAnnotations(meta)
                return a != nil &amp;&amp; a[controller.PVCProtectionComplete] == "yes"
        }</span>)
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
